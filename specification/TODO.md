- Fix insert and remove from lists since it now accepts non-number keys.
- Can't have a symbol as the first value in a function list? (Fix defer and evaluate examples.) The problem is with creating deferred functions since that quotes everything inside.
  - Have a helper to create simple anonymous functions? Won't have super easy and concise function literals anymore. Ok anyway for readability? Not a huge loss since it would have dynamic binding anyway, which wouldn't be used often? Or allow lists to be callable as well? Won't work well for whitespace indentation since it'll behave differently than other non function prototypes. No need for more specific syntax, and still needs to call evaluate since unbound variables in function lists need to also be evaluated.
  - `(code + 1 \x)`
  - `(function [x y] (+ x y))`
  - It only evaluates all its arguments and then adds them to an empty function list. Has the benefit of not needing specific syntax.
  - `()` calls a function list
  - `\()` creates a deferred function list
  - `[]` creates a function list
- Specify prototypical inheritance (differential inheritance, eg. intro, `get`, `insert` and `remove` handling, etc): http://steve-yegge.blogspot.com/2008/10/universal-design-pattern.html
- Evaluate typing difficulty of each identifier and syntax quantitatively.
  - Can the syntax grammar be simplified without hurting readability and flexibility?
  - Use easier synonyms for hard to type words.
  - Bulk analyze source code out there for analysis?
  - Frequency of syntax tokens, familiarity, ease of typing, speaking, identifiers.
  - https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(syntax)
  - http://hyperpolyglot.org/scripting
  - https://github.com/anvaka/common-words/blob/master/README.md
- http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey
- "Empirical Analysis of Programming Language Adoption", Leo A. Meyerovich, Ariel Rabkin: http://sns.cs.princeton.edu/docs/asr-oopsla13.pdf
- Look for best/worst features of other languages: Wren, Perl, F#, Matlab, Rust, Ruby, Go, Julia, JavaScript, Clojure, Kotlin, Python, Haskell, Erlang, Typed Racket, PureScript, Elm, Io, Smalltalk, Java, Scheme, ML, Lua, Haxe, Tcl, Shen, REBOL, Wolfram, HyperCard, Awk, Parabola.io
- Reactive programming?
- Indentation based syntax? The REPL becomes the shell, it just adds global functions as commands and other niceties.
  - If a line starts with a parenthesis it disables significant indentation inside the entire expression.
  - Otherwise each new line is a function call, with same-line arguments passed as-is, and indented new lines passed as function calls, unless it's a keyword argument.
  - All data types are callable as functions, and except for functions each value returns itself as the result.
- Guarantee efficient self-recursive function calls, tail function calls, and self-tail function calls?
- Add a built-in CAS (Computer Algebra System) to not loose any precision even when dealing with irrational numbers? Make math functions allow symbols? See Maxima Algebra System which uses Lisp, and GNU Octave.
