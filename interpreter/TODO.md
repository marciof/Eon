- Make Err use Log, to avoid needing a C stdlib. Build a native library, that can be used by the js build.
- Add Travis CI build matrix for the different builds (native, js, i386) and OSes.
- Regularly test building on Debian 32-bit 64-bit, Windows, OSX.
- Redesign architecture, to make it easier to embed, no singletons, and easier to unit test:
  - Avoid all these repeated calls for `*_get()`?
  - Remove stop modes and use only reset or halt
  - System_new(Log, Memory, argc, argv) // it's dynamic (eg. native, multiple interpreters)
  - System_get(Log, Memory, argc, argv) // it's static, not part of the interface, it's up to each host
  - System_stop(System)
  - main(multiboot_magic_num, multiboot_info)
- Make it more resilient, warn more instead of aborting.
- Add location to log calls? function, file, line? Or to warnings and errors only?
- Add color to native logging.
- Tests (unit, functional), coverage, lint, static analysis, continuous integration, memory check (Valgrind).
  - Automation: Vagrant, Docker?
  - https://autotest.github.io
  - https://scan.coverity.com
  - https://travis-ci.org # validate `.travis.yml` file, fix build
  - https://github.com/andrewrk/malcheck
  - https://github.com/google/sanitizers
  - http://clang-analyzer.llvm.org
- Logging of long integers.
- Add support for "amd64"?
  - ASFLAGS += -f elf64
  - CCFLAGS += -m64
  - LINKFLAGS += -m elf_x86_64
- Upgrade to Multiboot 2?
- https://github.com/copy/v86
- Option or tool to validate Coding Style guidelines.
- Prototyping:
  - "Crafting Interpreters", Bob Nystrom: http://craftinginterpreters.com
  - "LispOS - Specification of a Lisp operating system.", Robert Strandh: http://metamodular.com/lispos.pdf
  - lexical analysis: Lexer, Tokenizer, Scanner / syntax analysis: Parser, Syntax Tree, Parse Tree
  - Start adding unit tests.
  - Add `getopt` with help screen, options, and version.
  - Add flag option to print token stream.
  - Add flag option for `-e` expressions.
  - Add verbose option, print func/file/line on errors only in debug mode.
  - Add few functional high-level black-box language tests, eg. input "(+ 1 2)", translate to JavaScript, run, output "3". (Or even with the token stream option alone as well). With Valgrind.
  - C frontend, JavaScript backend: can reuse frontend and AST for the final version, and with JavaScript it's easy to get something running.
  - Unix tools philosophy for the interpreter?
    - Make a shell/REPL so that I can start using it ASAP.
    - Makes it easier to integrate in/with other tools?
    - Command line options for each stage for textual output. Easier to debug and integrate.
      - stream tokens from input, one per line
      - then parser
      - etc
  - Improve interpreter step by step: REPL/shell, local/remote debugger, stdin/stdout filter.
  - Add requirements one by one, even if with limitations (eg. no fully unlimited precision arithmetic at first): immutable collections, Unicode text, prototypical inheritance, first class scope, unlimited precision arithmetic, homoiconic, unevaluated arguments.
  - When done with JavaScript backend, start translating to PicoLisp (or even ECL, Common Lisp, Clojure) since it can be embedded (verify first), and reuse the tests written previously.
  - Skip translation and interpret directly. Look to PicoLisp for inspiration. Maybe still leave translation in as an option, especially if to JavaScript since that also makes the browser another possible host and can be useful (lower barrier to entry and also ability to use a single language full-stack).
    - http://www.nongnu.org/libunwind/
    - https://sourceware.org/libffi/
    - libreadline
    - GNU MP / MPFR
  - Finally integrate with the "core" hooks so that it works with any host layer available.
